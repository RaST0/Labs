//int main()
// {	
	/* if - оператор условного перехода
	if(лог_улс)
	if ()
	{
	 //код,выполняемый если true
	}

	if(лог_усл)
	{
	 //код,выполняемый если лог_усл == true
	}
	esle
	{
	 //код, выполняемый в противном случае
	}
	*/
/*
	int a = 10, b = 15, c = 15;
	if (a == b) // == - логический оператор сравнений, возвращает true только если оба операнда равны
				// != - логический оператор, проверяющий неравенство операндов, возвращает true только если оба оператора НЕ равны
	{
		std::cout << "a == b" << std::endl; // a равно b
	}
	else
	{
		std::cout << "a != b" << std::endl; // a НЕ равно b
	}
	std::cout << std::endl;*/
	/* switch - оператор условного перехода с несколькими вариантами
	   switch(выражение1)
	   {
		 case выражение2:
		 {
		  // действия, выполняемый если выражение2 == выражение1
		  break;
		 }
		 case выражение3:
		 {
		  // действия, выполняемый если выражение3 == выражение1
		  break;
		 }
		 default:
		 {
		  // действия, выполняемые, если ни одно выражение не подошло
		  break;
		 }
	   }
	*/


	/*int page_number = 0; // 0 - стартовая страница, 1 - страница сообщений, 2 - страница новостей, 4 - страница настроек
	switch (page_number)
	{
	    case 0:
	     {
			std::cout << "Start page" << std::endl; // действия, выполняемый если выражение2 == выражение1
			break;
	     }
        case 1:
	     {
			std::cout << "Message page" << std::endl; // действия, выполняемый если выражение3 == выражение1
			break;
	     }
		case 2:
		{
			std::cout << "News page" << std::endl; // действия, выполняемый если выражение2 == выражение1
			break;
		}
		case 3:
		{
			std::cout << "Settings page" << std::endl; // действия, выполняемый если выражение2 == выражение1
			break;
		}
	    default: 
	     {
			std::cout << "Some another page" << std::endl;// действия, выполняемые, если ни одно выражение не подошло
			break;
	     }
	}
	std::cout << std::endl;
		// switch целесобразно применять если число вариантов от 3..5
		// если вариантов больше, их следует задавать таблицей ( массивом ) 
		// и проверять таблицу на совпадения 
	
    /* for - оператор цикла с отсчётом

	for(целочисл_переменная; условие_продолжения; повторяемое действие)
	{
		//действие, повторяемые, пока (условие_продолжения == true)
	}
	*/
	/* int m = 15;
	//типичный случай: задают целую переменную-счётчик int i;
	//задают максимальное значение ( i < 10 );
	//задают возрастание/уменьшение i ( i++)
	for (int i = 0; i < 10; i++)
	{
		int l = 20;
		std::cout << "i = " << i << std::endl;
		std::cout << "l = " << l << std::endl;
		std::cout << "m = " << m << std::endl;
		l++;
		m--;
		//действие, повторяемые, пока i < 10
	}*/
	//std::cout << "i = " << i << std::endl; переменная цикла снаружи не видна ( исчезает ) 
	//std::cout << "l = " << l << std::endl; переменная цикла снаружи не видна ( исчезает )
//	std::cout << "m = " << m << std::endl;
	/*

	std::cout << std::endl;
	// ниже приведен оператор с пустыми круглыми скобками
	int k = 0; // объявляем переменную счетчик все цикла
	for (;;)
	{
		k++;
		std::cout << "k = " << k << std::endl;
		if (k >= 10)
		{
			break;
		}
	}
	std::cout << std::endl;
	//также возможет такой вариант
	for (int i = 0, j = 5; // через "," можно перечислить сколько угодно операторов
		i+j < 10;
		i++, j = j + 2, std::cout << "i=" << i << '\t' << "j= " << j << std::endl) */ // через "," можно перечислить сколько угодно операторов
	{
		//действие, повторяемые, пока i + j < 10
	}

	// ++ оператор ИНКРЕМЕНТА - увелечения на 1
	// -- оператор ДЕКРЕМЕНТА - уменьшения на 1

	// переменные объявленные в фигурных скобках цикла видно только внутри цикла 
	// кроме того, переменные объявленные в фигурных скобках, перезаписываются каждую итерацию
	// как только цикл закрывается переменная и ее содержимые недоступно

	// переменные объявленные в фигурных скобках цикла видно только внутри цикла 

	/*
	std::cout << std::endl;
	/* while - действия выполняются до тех пор, пока условие ==true */
   /* int rnd = 0.0;

	srand(100); // (time(0) - возвращает текущее время в секундах, требуется #include <ctime>
	while (rnd < RAND_MAX/2)
	{
		rnd = rand(); //случайные числа, однородно распределеные от 0 до MAX_RAND
		std::cout << "rnd = " << rnd << std::endl;

		// оператор break тоже работает с while
	}
/*
	int l = 0;
	while (l < 10)
	{
		if (l == 5)
		{
			l++;
			continue;
		}
		if (l >= 10)
		{
			break;
		}
		std::cout << "l = " << l << std::endl;
		l++;
		*/
		// оператор break тоже работает с while
	// } */
		// while - цикл с пред-условием, т.е сначало проверяется уловие, затем выполняется действие
	
	/* do while */
	
	/*   Умножение 2-х матриц 
	int A[3][3] = { { 1, 2, 3 }, // объявляем матрицу А
					{ 4, 5, 6 },
					{ 7, 8, 9 }};

	int B[3][3] = { { 10, 11, 12 }, // объявляем матрицу B
					{ 13, 14, 15 },
					{ 16, 17, 18 }};

	int C[3][3] = { { 0, 0, 0 }, // инициализируем неизвестную матрицу C нулями
					{ 0, 0, 0 },
					{ 0, 0, 0 }};
					std::cout << std::endl;

	for (int i = 0; i < 3; i++) // проходим по всем строкам финальной матрицы
		{
		for (int j = 0; j < 3; j++) // проходим по всем столбцам финальной матрицы
			{

			C[i][j] = 0;
			for (int k = 0; k < 3; k++)// прописывается сумма для одного элемента финальной матрицы
			{
				C[i][j] += A[i][k] * B[k][j]; // todo прописать сумму c[i][j] = c[i][j]+
			}
			std::cout << "Result = " << C[i][j] << std::endl; // выводим результат в консоль
		}
	}
	std::cout << std::endl; */
	/* Сложение 2-х матриц */ /*
	int A[3][3] = { { 1, 2, 3 }, // объявляем матрицу А
					{ 4, 5, 6 },
					{ 7, 8, 9 } };

	int B[3][3] = { { 10, 11, 12 }, // объявляем матрицу B
					{ 13, 14, 15 },
					{ 16, 17, 18 } };

	int C[3][3] = { { 0, 0, 0 }, // инициализируем неизвестную матрицу C нулями
					{ 0, 0, 0 },
					{ 0, 0, 0 } };
	for (int i = 0; i < 3; i++) // проходим по всем строкам финальной матрицы
	{
		for (int j = 0; j < 3; j++) // проходим по всем столбцам финальной матрицы
		{

			C[i][k] = 0;
			for (int k = 0; k < 3; k++)// прописывается сумма для одного элемента финальной матрицы
			{
				C[i][j] += A[i][k] + B[k][j]; // todo прописать сумму c[i][j] = c[i][j]+
			}
			std::cout << "Result = " << C[i][j] << std::endl; // выводим результат в консоль

		}


		
	}
	getchar();
    return 0;
}
*/