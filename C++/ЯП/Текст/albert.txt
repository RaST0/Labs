// Lab4.cpp: определяет точку входа для консольного приложения.
//

#include "stdafx.h"
#include <iostream>

// Функция - фрагмент кода, имеющий свое собственное название ( индентификатор );
// А так же интерфейс - входные / выходные параметры.


/*возвращаемый_тип имя_функции(тип имя_параметра, тип имя_параметра2,  ...)*/
int matrix_determinant(int arr[3][3]); // Объявление фукнции отдельно от ее определения 
int fnc1(double some_double)
{
	some_double = 1000.5; // Параметры функции можно поменять, но изменения н	е сохраняться после выхода.
	return 1;
}
// функции, объявленные таким образом, параметры передаются как копии некоторых внешних данных
// в первую функцию передается arr ( указатель на начало массива ) , каждый элемент не копируется
// во вторую передаётся double
// если внутри функции в такие параметры что-то будет перезаписано , это новое значение
// никаким образом не будет получено снаружи при выходе из функции
// такая дача параметром называется передачей ПО ЗНАЧЕНИЮ

// если параметры нужно менять в функции и возвращать из нее
// нужно объявлять передачу по ссылке

void fnc2(int a, int b, int c, //выходные параметры, переданные по значению
	int & d, int & e, int & f) // выходные параметры, которые могут быть возвращены после срабатывания функции
{
	d = a + b;
	e = c - b;
	f = c * c;
}
int fnc3(double a, double b, //выходные параметры, переданные по значению
	double &c, double &d) // параметры, которые могут быть возвращены вовне предаются по ССЫЛКЕ
{
	c = a + b;
	d = a - b;
	return 0;
}

// пример fnc2 - САМОСТОЯТЕЛЬНО	
	
	

int main()
{
	/*
	int a;
	double b = 0.5;
	int c = 1;
	int matr[3][3] = { {1,2,3},
					   {4,5,6},
					   {7,8,9} };
	a = matrix_determinant(matr);
	std::cout << "matrix_determinant(matr) = " << a << std::endl;
	fnc1(b); // параметр b меняется внутри функции
	std::cout << "b = " << b << " not changed " << std::endl;

	int i1 = 1, i2 = 2, i3 = 3,
		i4 = 4, i5 = 5, i6 = 6;
	//пример с fnc2
	
	*/
	/* double k = 10.5;
	int m = fnc1(k);
	std::cout << "fnc1(k) = " << m << std::endl;

	double a = 1.1, b = 2.2, c = 3.3;
	m = fnc2(a, b, c);


	std::cout << "m = " << m << "a =" << a << "b = " << b << "c =" << c << std::endl;
 */
	double k = 10, l = 11, n = 15, o = 19;
	std::cout << "n & o before call" << n << '/t' << o << std::endl;
		fnc3(k, l, n, o);
	std::cout << "n & o after call" << n << '/t' << o << std::endl;

	// Передача параметров по ссылке чаще всего применяется,
	// когда измененные в функции значения необходимо вернуть вовне
	// особенно когда возвращаемых значений несколько
	// они передаются и возвращаются через параметры по ссылке
	
	getchar();
	return 0;
}
int matrix_determinant(int arr[3][3])
// определение фунцкии
{
	int det = 123456;
	// Здесь прописываются действия с параметром, чтобы получить выходное значение
	// Здесь считали int det;
	return det;
}
	// Функция должна быть объявлена до того момента, когда она используется, 
	// Т.к компилятор проходить текст лишь однажды и например найдя функцию в конце, он не возвратится в начало
	// Заголовок функции можно объявлять до вызова ( объявления ).
	// А само тело функции ( определение ) в этом случае может быть в любом месте кода.

/*int fnc3(double a, double b, //выходные параметры, переданные по значению
	double &c, double &d) // параметры, которые могут быть возвращены вовне предаются по ССЫЛКЕ
{
	c = a + b;
	d = a - b;
	return 0;
}
*/
/* int fnc2(double a, double b, double c)
{//определение/реализация/тело функции
//операции
	int i = a * b * c; //в результате умножения двух double получается также double,
					   // однако он округляется до int, т.к значение выражения
					   // объявлено пользователем как int
	a = 15; c = 100500; //
	return i; // возвращаться должно значение того же типа, что и функция, т.е int
}
*/
//Функция которая не должна возвращать параметров объявляется типом void