// ConsoleApplication1.cpp: определяет точку входа для консольного приложения.
//

#include "stdafx.h"
#include <iostream>

/* Лабараторная работа 2  Массивы и указатели   */


int main()
{
	// переменная, хранящая другой адресс другой переменной в памяти, называется указателем ( pointer )

	int a = 231;
	double dbl = 10.005;
	// синтаксис объявления указателей	
	int * ptr_int = &a ;
	double * ptr_dbl = &dbl ;

	// все указатели всегда одной и той же разрядности ( размера )
	std::cout << "int pointer size = " << sizeof(ptr_int) << std::endl;
	std::cout << "double pointer size = " << sizeof(ptr_dbl) << std::endl;
	std::cout << "char pointer size = " << sizeof(char*) << std::endl;
	std::cout << "long long pointer size = " << sizeof(long long *) << std::endl;
	std::cout << "bool  pointer size = " << sizeof(bool *) << std::endl;
	
	// содержимое указателей
	std::cout << std::endl << "ptr_int = 0x" << std::hex << ptr_int << std::endl;
	// std::hex включает отображение целых чисел по 16-тиричной системе
	// пока не будет включена другая система счисления подобным образом все числа 
	// будут печататься в х16 системе
	std::cout << "ptr_ch = 0x" << ptr_dbl << std::endl;
	
	// в дальнейшем будет показано, что каким бы ни был огромным тип данных ( строка, объект, массив )
	// указатель на него всегда будет занимать 4/8 байт ,что и является основным преимуществом указателей


	// оператор разыменования указателей : чтобы получить значение, хранящееся по данному указателю,
	// нужно еще раз применить оператор *
	std::cout << std::endl << "*ptr_int = " << std::dec << *ptr_int << std::endl;
	std::cout << "* ptr_dbl = " << *ptr_dbl << std::endl;
	
	 //массив - блок из нескольких однотипных данных
	 //задавать массивом удобно ;
	 // 1) вектора и матрицы
	 // 2) множество точек из 3D и 2D геометрии
	 // 3) просто какой-либо числовой ряд, таблица и т.д.
	 // 4) строка - массив символов
	 // 5) видеобуфер ( двухмерный массив, соответствующий пикселям экрана)


	//int arr[5];//
	//int arr[5] = { 0 };//
	int arr[5] = {1, 50, 11, 12, 1000} ; // одномерный массив из 10 целых знаковых чисел
    // в ОП массив хранится компактно ( без разрывов, элемент за элементом)
	// нумеруются массивы с 0  до (длина - 1 )

	std::cout << arr[0] << '\t' <<
	     arr[1] << '\t' << //в одинаковых кавычках - только 1 символ ( char ), в двойных - любое множество
	     arr[2] << '\t' << //в общем случае можно везде использовать двойные
	     arr[3] << '\t' <<
		 arr[4] << '\t' << std::endl;
	std::cout << "arr =  " << arr << std::endl;
	std::cout << "*arr =  " << *arr << std::endl;
	std::cout << "*(arr+4) =  " << *(arr+4) << std::endl;



	for (int *i = &a - 16;
		i < &a + 16;
		i++)

	{
		std::cout << "0x" << i <<  '\t' << *i << std::endl;
	}
    
	
	// индефикатор (имя) массиво взятое без индекса само является указателем
	// 

	int arr2D[3][3] = { {1, 2, 3},
						{4, 5, 6},
						{7, 8, 9} };

	
	// если бы хотели занулить весь массив, написали бы int arr[3][3] = {0}
	// размерности массивов задаются статически, нельзя задавать размер массива с помощью переменной
	// для этого нужно воспользоваться нужно воспользоваться динамической памятью и совсем другим синтаксисом объявления
	std::cout << std::endl;
/* std::cout <<	arr2D[0][0] << '\t' << arr2D[0][2] <<	arr2D[0][0] << '\t' << std::endl <<
<<	arr2D[1][0] << '\t' <<	arr2D[1][1] << '\t' <<	arr2D[1][2] << '\t' << std::endl <<
<<	arr2D[2][0] << '\t' <<	arr2D[2][1] << '\t' <<	arr2D[2][2] << '\t' <<std::endl << 
	
*/
    
	for (int i = 0; 
		i<3; 
		i++)
	{
		for (int j = 0; j < 3; std::cout << arr2D[i][j] << '\t', j++) { }


			std::cout << std::endl;
	}
	
	std::cout << "*(*(arr2D+2)+2) = arr2D[2][2] = " << *(*(arr2D + 2) + 2) << std::endl;
 		// Статические массивы представляют собой в ОП компактное сплошное множество
	    // arr2D[1] тип *int - указатель на одну строчку - одномерный массив внутри двухмерного
		// arr2D[1][1] тип int - двойные скобки дважды разыменуют указатель
	    // все статические массивы в памяти расположены компактно
	getchar();

    return 0;
}

