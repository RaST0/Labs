// Lab4.cpp: определяет точку входа для консольного приложения.
//

#include "stdafx.h"
#include <iostream>
#include <ctime>
#include <Lab3.h>

/*возвращаемый_тип имя_функции(тип имя параметра,тип имя параметра_2,...*/
/*функция должна быть объявлена до ее первого использования тк компилятор проходит  текст лишь однажды и найдя функцию в конце он не возвратится в начало*/

int matrix_determinant(int arr[3][3]);//объявление функции отдельно от ее определения
									  //в функции,объявленные таким образом,параметры передаются как копии некоторых внешних данных
									  //в первую функцию передаётся копия arr(указатель на начало массива),
									  //во вторую функцию передается копия double
									  //если внутри функции в такие параметры
int fnc1(double some_double)
{
	some_double = 1000.5;
	return 0;
}
int matrix_determinant(int arr[3][3])
{

	int det = 123456;
	//здесь прописываются действия с параметром чтобы получить выходное значение
	//здесь расчитали int det;
	//функция должна быть \
		//заголовок можно помещать до вызова , само тело функции(
// если параметры нужно меняменять в функции и возвращать из нее
//нужно объявить передачу по ссылке
//это особенно практично когда из функции необходимо вернуть несколько переменных 


	return det;



}
void fnc2(int a, int b, int c,// входные параметры переданные по значению
	int & d, int & e, int & f)//параметры которые могут быть возвращены после срабатывания
{
	d = a + b;//передача параметров по ссылке чаще всего применяются, когда измененные в функции значения необходимо вернуть вовне
			  //
	e = c - b;
	f = c*c;


}


//int main1()
//{
//	int a;
//	double b = 0.5;
//	int matr[3][3]{ { 1,2,3 },
//	{ 4,5,6 },
//	{ 7,8,9 } };
//	a = matrix_determinant(matr);
//	std::cout << "matrix_determinant(matr)" << a << std::endl;
//	fnc1(b);
//	std::cout << "b=" << b << "not changed" << std::endl;
//
//
//	int i1 = 1, i2 = 2, i3 = 3,
//		i4 = 4, i5 = 5, i6 = 6;
//}
//пример с fnc2
//int fnc2(double some_double);
inline int fnc3_1(double a, double b,//входные параметры,переданные ПО ЗНАЧЕНИЮ
	double &c, double &d)//параметры которые могут быть возвращены вовне передаются ПО ССЫЛКЕ
						 //ОПРЕДЕЛЕНИЕ/РЕАЛИЗАЦИЯ /ТЕЛО ФУНКЦИИ
{//если тело функции содержит малое количество операторов,может получиться что пролог и эпилог составляют основную часть функции
 //и соответсвено отнимают наибольшее время работы функции в этом случае имеет смысл настроить функцию так чтобы пролог и эпилог не создавались
 //а тело функции срабатовало бы в том же месте где ее вызывали 
 //

	c = a + b;
	d = a - b;
	return 0;//функция которая не должна возвращать параметры объявляется с типом VOID
}
int  fnc3_2(double a, double b,//входные параметры,переданные ПО ЗНАЧЕНИЮ
	double &c, double &d)//параметры которые могут быть возвращены вовне передаются ПО ССЫЛКЕ
						 //ОПРЕДЕЛЕНИЕ/РЕАЛИЗАЦИЯ /ТЕЛО ФУНКЦИИ
{//если тело функции содержит малое количество операторов,может получиться что пролог и эпилог составляют основную часть функции
 //и соответсвено отнимают наибольшее время работы функции в этом случае имеет смысл настроить функцию так чтобы пролог и эпилог не создавались
 //а тело функции срабатовало бы в том же месте где ее вызывали 
 //

	c = a + b;
	d = a - b;
	return 0;//функция которая не должна возвращать параметры объявляется с типом VOID
}
//ПЕРЕДАЧА МАССИВОВ В ФУНКЦИЮ
//первый способ (и возвращения) массива в функцию 

void fnc4_1(int matr[3][3])//передается не копия всего массива, а указвтель на первый элемнт
						   //следовательно , меняется тоже исходный внешний оригинальный массив
{
	matr[1][1] = 10;
	return;
}
int main()
{
	double k = 10.5;

	int m = fnc1(k);
	std::cout << "fnc3(k)=" << m << std::endl;
	double a = 1.1, b = 2.2, c = 3.3, d = 4.4;
	m = fnc3_1(a, b, c, d);
	std::cout << "m=" << m << "a=" << a << "b=" << b << "c=" << c << "d=" << d << std::endl;
	double p = 10, l = 11, n = 15, o = 19;
	std::cout << "n & o before call" << n << '\t' << o << std::endl;
	fnc3_1(p, l, n, o);
	std::cout << "n & o after call" << n << '\t' << o << std::endl;

	int matr[3][3]{ { 1,2,3 },
					{ 4,5,6 },
					{ 7,8,9 } };
	fnc4_1(matr);
	std::cout << "matr[1][1]=" << matr[1][1] << std::endl;
	//второй способ передачи(и возвращения) масива в функцию

	// третий способ передачи ( и возвращения ) массива в функцию
	void fnc4_3(int(&matr)[3][3]);
	{
		matr[1][1] = 10;

	}
	//четвертый способ переда
	{void fnc4_4(int ** matr); // пользователь должен самостоятельно следить за тем
							   // чтобы индекс не превышал длину массива


	matr[1][1]; }





	//бенчмарк по производительности inline и stdcall
	time_t tstart = time(0),
		tend = time(0);//записывается текущее время
	int i = 0;
	for (i = 0; i < 500000000; i++)
	{
		fnc3_1(a, b, c, d);
	}
	tend = time(0);//записывается текущее время на момент окончания
	std::cout << "It took" << difftime(tend, tstart) << "second(s)for inline" << std::endl;//в debug режиме функцие все не inline(не подставляемые ) а обычные
	for (i = 0; i < 500000000; i++)
	{
		fnc3_2(a, b, c, d);
	}
	tend = time(0);
	std::cout << "It took" << difftime(tend, tstart) << "second(s)for stdcall" << std::endl;


// Если функция определена в другом модуле перед именем пишется спецификатор extern ( внешний ) 
// Если тело функции содержит мало кол-во операторов, может получится 
// что ПРОЛОГ и ЭПИЛОГ составляют основную часть функции, и соответственно, 
// Отнимают наибольшее время работы функции
// В этом случае имеет смысл настроить функцию так, чтобы ПРОЛОГ и ЭПИЛОГ не создавались
// А тело функции срабатывало бы в том же месте, где ее вызвали
// Это достигается с помощью директивы inline
// По сути, в любое место где вызывается inline-функция, просто копируется ее операторы



// Git - система управления версиями позволяет : 
// 1. Создавать снимки файлов на определенных этапах ( версии )
// 2. Позволяет откатываться до любой версии
// 3. Позволяет вести коллективную разработку
// 4. Позволяет работать как с локальным так и с удаленным репозиторием ( хранилищем ). Репозиторий - файл + история.
// 5. Лучше всего git работает с текстовыми файлами ( html, xml, code и т.д ) в этом случае история изменения файлов 
// записывается как история добавления / удаления строк и символов


/* 
	 ОСНОВЫ РАБОТЫ С GIT

	 1. Начало работы - инициализация репозитория :
	 -CD <папка sln решения>
	 git init
	 появляется скрытая папка .git, где и будет хранится история изменений и настройки


	 2. По умолчанию git будет фиксировать историю кода с известными расширениями :
	 txt, cpp, h, hpp, hxx, c
	 py, xml, html
	 Однако в репозиторий также требуется включать и файлы проектов и решений
	 которые git сам не учитывает
	 для этого нужно воспользоваться командой

			git add <имя_файла>
	 
	 Достаточно добавить учет файла в репозиторий 1 раз
	 Категорически не следует добавлять исполняемые файлы,
	 Временные и автоматически генерируемые файлы : *.exe, *.lib, *.dll, *.ipch, *.db, *.pdb
	 Не следует добавлять целиком папки /x86, /x64, /release, /debug
	 
	 3. Зафиксировать версию ( снимок ) группы файлов
			
			git commit -m"Комментарий к версии"

		Ввод комментария строго обязателен.
		

	 4. Для синхронизации с удаленным репозиторием нужно:

			-закоммитить изменения в локальном
			-прописать адрес удаленного

			git remote add <краткий_псевдоним> <ссылка>
			
			например,

			git remote add gitlab https://gitlab.com/myproject.git

			-отправить на удаленный

			git push <краткий_псевдоним> master

	5. В любой момент можно посмотреть статус репозитория через 
	
			git status


	6. Получить справку
			
			git <имя_команды> help



*/