// Lab3.cpp: определяет точку входа для консольного приложения.
//
// Массивы
#include "stdafx.h"
#include <iostream>
#include <ctime>

void fnc1(int A, int B, int & C) // Умножение матрицы на матрицу
					{
					C = A * B;
					}

void fnc2(int D, int E, int & F) // Умножение вектора на матрицу
					{
					F = D * E;
					}

void fnc3(int G, int H, int & L) // Сложение матриц
					{
					L = G + H;
					}

void fnc4(int O, int P, int & S) // Сложение векторов
					{
					S = O + P;
					}

int main()
{
int A[3][3] = { { 1,2,3 }, // обозначаем матрицу А
				{ 4,5,6 },
				{ 7,8,9 } };


int B[3][3] = { { 10,11,12 }, // обозначаем матрицу B
				{ 13,14,15 },
				{ 16,17,18 } };

int C[3][3] = { { 0,0,0 },  // инициализируем нулями матрицу С
				{ 0,0,0 },
				{ 0,0,0 } };





// to do объявление С
std::cout << std::endl;

for (int i = 0; i < 3; i++) // проходим по всем строкам финальной матрицы
			{
for (int j = 0; j < 3; j++) // проходим по всем столбцам финальной матрицы
			{
					C[i][j] = 0;
for (int k = 0; k < 3; k++) // прописывается сумма для одного элемента финальной матрицы
			{
					C[i][j] += A[i][k] * B[k][j];
			}
					std::cout << C[i][j] << " C = " << std::endl; // выводим результат в консоль
			}
			}
std::cout << std::endl;



int D[1][3] = { { 3,2,1 } }; // удобнее всего обозначит вектор как одномерный массив

int E[3][3] = { { 1,2,3 },
				{ 4,5,6 },                       // обозначаем матрицу Е
				{ 7,8,9 } };

int F[1][3] = { { 0,0,0 } };   // инициализируем нулями F

// to do объявить F
std::cout << std::endl;

for (int i = 0; i < 1; i++) // проходим по всем строкам финальной матрицы
{
for (int j = 0; j < 3; j++) // проходим по всем столбцам финальной матрицы
{
F[i][j] = 0;
for (int k = 0; k < 3; k++) // прописывается сумма для одного элемента финальной матрицы
{
F[i][j] += D[i][k] * E[k][j];
}
std::cout << F[i][j] << " F =  " << std::endl;
}
}
std::cout << std::endl;


int G[3][3] = { { 1,2,3 },
				{ 4,5,6 },
				{ 7,8,9 } };


int H[3][3] = { { 10,11,12 },
				{ 13,14,15 },
				{ 16,17,18 } };

int L[3][3] = { { 0,0,0 },
				{ 0,0,0 },
				{ 0,0,0 } };
std::cout << std::endl;

{	for (int i = 0; i < 3; i++) // проходим по всем строкам финальной матрицы

for (int j = 0; j < 3; j++) // проходим по всем столбцам финальной матрицы
{
L[i][j] = 0;

{
L[i][j] = G[i][j] + H[i][j];
}
std::cout << L[i][j] <<  " L = " << std::endl;
}
}
std::cout << std::endl;

int O[1][3] = { { 3,2,1 } };

int P[1][3] = { { 4,3,2 } };

int S[1][3] = { { 0,0,0 } };

std::cout << std::endl;


for (int i = 0; i < 1; i++)
{                                 // проходим по всем элементам финального вектора
for (int j = 0; j < 3; j++)
{
S[i][j] = 0;

{
S[i][j] += O[i][j] + P[i][j]; // производим сложение двух векторов
}
std::cout << S[i][j] << "S =  " << std::endl;
}
}
std::cout << std::endl;




int T[3] = { 3,2,1 };

int U[3] = { 4,3,2 };

int V = 0; // результат скалярного произведения- число

std::cout << std::endl;


for (int i = 0; i < 3; i++)
{                                 // проходим по всем элементам финального вектора

{

V = 0;

{
V += T[i] * U[i]; // производим скалярное произведение


}
std::cout << "V = " << V << std::endl;
}
}
std::cout << std::endl;

getchar();
return 0;
}

